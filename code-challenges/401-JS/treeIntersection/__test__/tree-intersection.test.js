const { Node, BinaryTree } = require('../../Data-Structures/tree/tree')
const treeIntersection = require('../tree-intersection')

describe('tree-instersection module:', () => {
  describe('treeIntersection()', () => {
    describe('preOrder()', () => {
      test('Return an array containing values found in both trees', () => {
        const treeA = new BinaryTree()
        treeA.root = new Node(10)
        treeA.root.left = new Node(13)
        treeA.root.left.left = new Node(5)
        treeA.root.left.left.left = new Node(20)
        treeA.root.left.left.right = new Node(11)
        treeA.root.left.right = new Node(6)
        treeA.root.left.right.left = new Node(8)
        treeA.root.right = new Node(30)
        treeA.root.right.left = new Node(95)
        treeA.root.right.right = new Node(0)

        const treeB = new BinaryTree()
        treeB.root = new Node(8)
        treeB.root.left = new Node(13)
        treeB.root.left.left = new Node(12)
        treeB.root.left.right = new Node(30)
        treeB.root.right = new Node(5)
        treeB.root.right.left = new Node(50)
        treeB.root.right.right = new Node(7)
        treeB.root.right.left.left = new Node(11)
        console.log(treeIntersection(treeA, treeB))
        expect(treeIntersection(treeA, treeB)).toStrictEqual([8, 13, 30, 5, 11])
      })
      test('Return an array containing a string when no matches found due to no values matching', () => {
        const treeA = new BinaryTree()
        treeA.root = new Node(-10)
        treeA.root.left = new Node(-13)
        treeA.root.left.left = new Node(-5)
        treeA.root.left.left.left = new Node(-20)
        treeA.root.left.left.right = new Node(-11)
        treeA.root.left.right = new Node(-6)
        treeA.root.left.right.left = new Node(-8)
        treeA.root.right = new Node(-30)
        treeA.root.right.left = new Node(-95)
        treeA.root.right.right = new Node(-1)

        const treeB = new BinaryTree()
        treeB.root = new Node(8)
        treeB.root.left = new Node(13)
        treeB.root.left.left = new Node(12)
        treeB.root.left.right = new Node(30)
        treeB.root.right = new Node(5)
        treeB.root.right.left = new Node(50)
        treeB.root.right.right = new Node(0)
        treeB.root.right.left.left = new Node(11)
        expect(treeIntersection(treeA, treeB)).toStrictEqual(['No matches found.'])
      })
      test('Return an array containing a string when no matches found due to an empty tree', () => {
        const treeA = new BinaryTree()
        treeA.root = new Node(10)
        treeA.root.left = new Node(13)
        treeA.root.left.left = new Node(5)
        treeA.root.left.left.left = new Node(20)
        treeA.root.left.left.right = new Node(11)
        treeA.root.left.right = new Node(6)
        treeA.root.left.right.left = new Node(8)
        treeA.root.right = new Node(30)
        treeA.root.right.left = new Node(95)
        treeA.root.right.right = new Node(0)

        const treeB = new BinaryTree()
        expect(treeIntersection(treeA, treeB)).toStrictEqual(['No matches found.'])
      })
    })
  })
})
